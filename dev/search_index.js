var documenterSearchIndex = {"docs":
[{"location":"functions/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"functions/","page":"Index","title":"Index","text":"CurrentModule = ClimateTools","category":"page"},{"location":"functions/","page":"Index","title":"Index","text":"Modules = [ClimateTools]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"functions/#ClimateTools.MSModel-Tuple{Any}","page":"Index","title":"ClimateTools.MSModel","text":"MSModel(ds; k_switching=2, intercept=\"switching\")\n\nCompute the autocorrelation of a dataset ds along the time dimension.\n\nArguments\n\nds: The input dataset.\nlags: The number of lags to compute autocorrelation for. Default is 30.\n\nReturns\n\nThe autocorrelation of the input dataset ds along the time dimension.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.autocorrelation-Tuple{Any}","page":"Index","title":"ClimateTools.autocorrelation","text":"autocorrelation(ds; lags=30)\n\nCompute the autocorrelation of a dataset ds along the time dimension.\n\nArguments\n\nds: The input dataset.\nlags: The number of lags to compute autocorrelation for. Default is 30.\n\nReturns\n\nThe autocorrelation of the input dataset ds along the time dimension.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.climato_tp-Tuple{Any}","page":"Index","title":"ClimateTools.climato_tp","text":"climato_tp(ds; fct::Function=sum, iduree=3, lead=0)\n\nCalcul de la somme des précipitations pour tous les mois pour la durée spécifié par iduree. En ce moment, l'overlap des années n'est pas pris en charge: si iduree=3, on aura un Cube qui contient les accumulations sur 3 mois pour toutes les séquences de 3 mois, allant de janvier (janvier-février-mars) à octobre (octobre-novembre-décembre). \n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.cumsum-Tuple{Any, Any}","page":"Index","title":"ClimateTools.cumsum","text":"cumsum(xout, xin)\n\nCompute the cumulative sum of the elements in xin and store the result in xout.\n\nArguments\n\nxout: An array to store the cumulative sum.\nxin: An array containing the elements to be summed.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.cumsum-Tuple{YAXArrays.Cubes.YAXArray, Vararg{Any, N} where N}","page":"Index","title":"ClimateTools.cumsum","text":"cumsum(cube::YAXArray, kwargs...)\n\nCompute the cumulative sum along the \"time\" dimension of the input cube.\n\nArguments\n\ncube: The input YAXArray cube.\nkwargs: Additional keyword arguments.\n\nReturns\n\nA new YAXArray cube with the cumulative sum computed along the \"time\" dimension.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.daily_fct-Tuple{Any, Any}","page":"Index","title":"ClimateTools.daily_fct","text":"daily_fct(xout, xin; fct::Function, index_list = time_to_index)\n\nApply a function fct to aggregate data from xin into xout on a daily basis used internally\n\nArguments\n\nxout: Output array to store the aggregated data.\nxin: Input array containing the data to be aggregated.\nfct: Function to be applied for aggregation.\nindex_list: (optional) Function to convert time to index.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.daily_fct-Tuple{YAXArrays.Cubes.YAXArray}","page":"Index","title":"ClimateTools.daily_fct","text":"daily_fct(cube::YAXArray; fct::Function=mean, shifthour=0, kwargs...)\n\nApply a function fct to process the data in cube on a daily basis. Assumes that the Cube have sub-daily values.\n\nArguments\n\ncube::YAXArray: The input data cube.\nfct::Function: The function to apply for processus sub-daily values. Default is mean.\nshifthour::Int: The number of hours to shift the time values. Default is 0.\nkwargs...: Additional keyword arguments to be passed to the aggregation function.\n\nReturns\n\nA new YAXArray with aggregated data on a daily basis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.diff-Tuple{Any, Any}","page":"Index","title":"ClimateTools.diff","text":"diff(xout, xin)\n\nCompute the difference between consecutive elements of xin and store the result in xout. A 0.0 is added at the beginning of the output array.\n\nArguments\n\nxout: An array to store the difference values.\nxin: An array of values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.diff-Tuple{YAXArrays.Cubes.YAXArray}","page":"Index","title":"ClimateTools.diff","text":"diff(cube::YAXArray, kwargs...)\n\nCompute the difference between consecutive time steps in the given cube.\n\nArguments\n\ncube::YAXArray: The input data cube.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nA new YAXArray object containing the difference between consecutive time steps.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.qqmap-NTuple{8, Any}","page":"Index","title":"ClimateTools.qqmap","text":"qqmap(dataout, obsvec, refvec, futvec, days, obs_jul, ref_jul, fut_jul; method::String=\"Additive\", detrend::Bool=true, order::Int=4, window::Int64=15, rankn::Int64=50, qmin::Real=0.01, qmax::Real=0.99, thresnan::Float64=0.1, keep_original::Bool=false, interp=Linear(), extrap=Interpolations.Flat())\n\nThe qqmap2 function performs quantile mapping bias correction on the futvec data using the obsvec and refvec data as references. It corrects the values in futvec for each day specified in days based on the quantiles estimated from the corresponding days in obsvec and refvec.\n\nArguments\n\ndataout: Output array where the corrected values will be stored.\nobsvec: Array of observed values.\nrefvec: Array of reference values.\nfutvec: Array of future values to be corrected.\ndays: Array of days of the year for which correction will be performed.\nobs_jul: Array of Julian day values corresponding to obsvec.\nref_jul: Array of Julian day values corresponding to refvec.\nfut_jul: Array of Julian day values corresponding to futvec.\n\nOptional Arguments\n\nmethod::String: Method used for correction. Default is \"Additive\".\ndetrend::Bool: Whether to detrend the data before correction. Default is true.\norder::Int: Order of the polynomial used for detrending. Default is 4.\nwindow::Int64: Size of the moving window for selecting reference values. Default is 15.\nrankn::Int64: Number of quantiles to estimate. Default is 50.\nqmin::Real: Minimum quantile value. Default is 0.01.\nqmax::Real: Maximum quantile value. Default is 0.99.\nthresnan::Float64: Threshold for the percentage of NaN values allowed in the data. Default is 0.1.\nkeep_original::Bool: Whether to keep the original values in case of too many NaN values. Default is false.\ninterp: Interpolation method used for building the correction function. Default is Linear().\nextrap: Extrapolation method used for building the correction function. Default is Interpolations.Flat().\n\nThe function modifies dataout in-place and returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ClimateTools.qqmap-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Index","title":"ClimateTools.qqmap","text":"qqmap(obs::YAXArray, ref::YAXArray, fut::YAXArray; method::String=\"Additive\", detrend::Bool=true, order::Int=4, window::Int=15, rankn::Int=50, qmin::Real=0.01, qmax::Real=0.99, thresnan::Float64=0.1, keep_original::Bool=false, interp=Linear(), extrap=Interpolations.Flat())\n\nThis function performs quantile mapping bias correction on data.\n\nArguments\n\nobs::YAXArray: The observed data.\nref::YAXArray: The reference data.\nfut::YAXArray: The future data.\nmethod::String: The method to apply on raw data for bias correction. Default is \"Additive\".\ndetrend::Bool: Whether to detrend the data before bias correction. Default is true.\norder::Int: The order of the polynomial used for detrending. Default is 4.\nwindow::Int: The window size (+/- window relative to a given julian day) for calculating the Julian days. Default is 15.\nrankn::Int: The number of quantiles to use for mapping. Default is 50.\nqmin::Real: The minimum quantile value. Default is 0.01.\nqmax::Real: The maximum quantile value. Default is 0.99.\nthresnan::Float64: The threshold for bias correcting a grid based in presence of NaN values. Default is 0.1 (i.e. if there is more than 10% of NaN values, the grid point is not corrected).\nkeep_original::Bool: Whether to keep the original data in the output if there is more than the threshold of NaN values. Default is false.\ninterp: The interpolation method to use between quantiles. Default is Linear().\nextrap: The extrapolation method to use over qmin and qmax. Default is Interpolations.Flat().\n\nReturns\n\nA bias-corrected YAXArray.\n\n\n\n\n\n","category":"method"},{"location":"indices/#Climate-Indices","page":"Climate Indices","title":"Climate Indices","text":"","category":"section"},{"location":"indices/#Indices","page":"Climate Indices","title":"Indices","text":"","category":"section"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"More than 20 climate indices are available in the package, such as the annual number of tropical nights, annual maximum and minimum, etc. You can calculate such indices simply with:","category":"page"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"ind = annualmax(C::ClimGrid)","category":"page"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"Which returns another ClimGrid. You can also map this ClimGrid with the mapclimgrid function and returns the climatological mean of the annual maximum (e.g. daily precipitation in the example below). A list of indices can be found in the documentation and in the functions.jl source code.","category":"page"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"mapclimgrid(ind) # mapping the indice previously calculated","category":"page"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"(Image: BNU-ESM)","category":"page"},{"location":"indices/#Ensemble-mean","page":"Climate Indices","title":"Ensemble mean","text":"","category":"section"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"You can calculate the ensemble mean with ensemble_mean function, where the input argument is an array of ClimGrids.","category":"page"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"Abstract example:","category":"page"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"C_model1 = ClimGrid(...) # model #1\nC_model2 = ClimGrid(...) # model #2\nens = [C_model1, C_model2] # Create an Array of ClimGrids\nE = ensemble_mean(ens) # Returns the mean of all models climatologies","category":"page"},{"location":"indices/#Climate-Indices-2","page":"Climate Indices","title":"Climate Indices","text":"","category":"section"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"Here's a list of climate indices currently provided by ClimateTools. This list may not be always up-to-date. See here for all exported functions.","category":"page"},{"location":"indices/","page":"Climate Indices","title":"Climate Indices","text":"annualmax\nannualmean\nannualmin\nannualsum\napprox_surfacepressure\ncustomthresover\ncustomthresunder\ndiurnaltemperature\nicingdays\nfrostdays\nprcp1\nsummerdays\ntropicalnights\nvaporpressure\nwbgt","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/#Merging-ClimGrid-type","page":"Interface","title":"Merging ClimGrid type","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Sometimes, the timeseries are split among multiple files (e.g. climate models outputs). To obtain the complete timeseries, you can merge 2 ClimGrid. The method is based on AxisArrays merging method and is overloaded for the ClimGrid type.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"C = merge(C1::ClimGrid, C2::ClimGrid)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"To merge multiple ClimGrid form an array of files, load has a method that accepts an array of files to merge.","category":"page"},{"location":"interface/#Operators","page":"Interface","title":"Operators","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Basic statistical functions are overloaded on ClimGrid.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"mean minimum maximum std var","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Basic arithmetic operators are also loaded.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"D = C + 2.0 # will add 2.0 to all elements of C\nD = C::ClimGrid - A::ClimGrid # subtract A from C (useful for climatological difference between a future and historical period\nD = C / A # Ratio of 2 ClimGrids","category":"page"},{"location":"interface/#Exporting","page":"Interface","title":"Exporting","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Exporting a ClimGrid to disk to a netCDF format can be done with the write function.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"write(C::ClimGrid, filename::String)","category":"page"},{"location":"maps/","page":"Visualization","title":"Visualization","text":"CurrentModule = ClimateTools","category":"page"},{"location":"maps/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"maps/","page":"Visualization","title":"Visualization","text":"Maps and plots are provided by the ClimatePlots package. See here for some examples.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Typical-workflow-for-a-climate-scenario","page":"Examples","title":"Typical workflow for a climate scenario","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note. Climate data can be downloaded at ESGF nodes","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note 2. The following example is somewhat convoluted, but it gives an overview of the main steps allowed by ClimateTools package.","category":"page"},{"location":"examples/#Exploration","page":"Examples","title":"Exploration","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First step before extracting the data is to explore the actual dataset at hand. The function Dataset (reexported from te NCDatasets.jl package) is used to examine the file(s). In this example, the simulation is from the MIROC5 model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Dataset(\"datafile.nc\")\n\nDataset: /path/to/file/tasmax_day_MIROC5_historical_r1i1p1_19900101-19991231.nc\nGroup: /\n\nDimensions\n   time = 3650\n   lat = 128\n   lon = 256\n   bnds = 2\n\nVariables\n  time   (3650)\n    Datatype:    Float64\n    Dimensions:  time\n    Attributes:\n     bounds               = time_bnds\n     units                = days since 1850-1-1\n     calendar             = noleap\n     axis                 = T\n     long_name            = time\n     standard_name        = time\n\n  time_bnds   (2 × 3650)\n    Datatype:    Float64\n    Dimensions:  bnds × time\n\n  lat   (128)\n    Datatype:    Float64\n    Dimensions:  lat\n    Attributes:\n     bounds               = lat_bnds\n     units                = degrees_north\n     axis                 = Y\n     long_name            = latitude\n     standard_name        = latitude\n\n  lat_bnds   (2 × 128)\n    Datatype:    Float64\n    Dimensions:  bnds × lat\n\n  lon   (256)\n    Datatype:    Float64\n    Dimensions:  lon\n    Attributes:\n     bounds               = lon_bnds\n     units                = degrees_east\n     axis                 = X\n     long_name            = longitude\n     standard_name        = longitude\n\n  lon_bnds   (2 × 256)\n    Datatype:    Float64\n    Dimensions:  bnds × lon\n\n  height  \n    Attributes:\n     units                = m\n     axis                 = Z\n     positive             = up\n     long_name            = height\n     standard_name        = height\n\n  tasmax   (256 × 128 × 3650)\n    Datatype:    Float32\n    Dimensions:  lon × lat × time\n    Attributes:\n     standard_name        = air_temperature\n     long_name            = Daily Maximum Near-Surface Air Temperature\n     units                = K\n     original_name        = T2\n     cell_methods         = time: maximum\n     cell_measures        = area: areacella\n     history              = 2011-10-19T12:39:31Z altered by CMOR: Treated scalar dimension: 'height'. 2011-10-19T12:39:31Z altered by CMOR: replaced missing value flag (-999) with standard missing value (1e+20). 2011-10-19T12:39:31Z altered by CMOR: Inverted axis: lat.\n     coordinates          = height\n     missing_value        = 1.0e20\n     _FillValue           = 1.0e20\n     associated_files     = baseURL: http://cmip-pcmdi.llnl.gov/CMIP5/dataLocation gridspecFile: gridspec_atmos_fx_MIROC5_historical_r0i0p0.nc areacella: areacella_fx_MIROC5_historical_r0i0p0.nc\n\nGlobal attributes\n  institution          = AORI (Atmosphere and Ocean Research Institute, The University of Tokyo, Chiba, Japan), NIES (National Institute for Environmental Studies, Ibaraki, Japan), JAMSTEC (Japan Agency for Marine-Earth Science and Technology, Kanagawa, Japan)\n  institute_id         = MIROC\n  experiment_id        = historical\n  source               = MIROC5 2010 atmosphere: MIROC-AGCM6 (T85L40); ocean: COCO (COCO4.5, 256x224 L50); sea ice: COCO (COCO4.5); land: MATSIRO (MATSIRO, L6); aerosols: SPRINTARS (SPRINTARS 5.00, T85L40)\n  model_id             = MIROC5\n  forcing              = GHG, SA, Oz, LU, Sl, Vl, SS, Ds, BC, MD, OC (GHG includes CO2, N2O, methane, and fluorocarbons; Oz includes OH and H2O2; LU excludes change in lake fraction)\n  parent_experiment_id = piControl\n  parent_experiment_rip = r1i1p1\n  branch_time          = 150015.0\n  contact              = Masahiro Watanabe (hiro@aori.u-tokyo.ac.jp), Seita Emori (emori@nies.go.jp), Masayoshi Ishii (ism@jamstec.go.jp), Masahide Kimoto (kimoto@aori.u-tokyo.ac.jp)\n  references           = Watanabe et al., 2010: Improved climate simulation by MIROC5: Mean states, variability, and climate sensitivity. J. Climate, 23, 6312-6335\n  initialization_method = 1\n  physics_version      = 1\n  tracking_id          = 54e617f1-31a5-47fd-bd57-8736bb7d00ef\n  product              = output\n  experiment           = historical\n  frequency            = day\n  creation_date        = 2011-10-19T12:39:31Z\n  history              = 2011-10-19T12:39:31Z CMOR rewrote data to comply with CF standards and CMIP5 requirements.\n  Conventions          = CF-1.4\n  project_id           = CMIP5\n  table_id             = Table day (26 July 2011) f21c16b785432e6bd3f72e80f2cade49\n  title                = MIROC5 model output prepared for CMIP5 historical\n  parent_experiment    = pre-industrial control\n  modeling_realm       = atmos\n  realization          = 1\n  cmor_version         = 2.7.1\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can see the dimensions of the data, as well as the name of the variable(s), in this case \"tasmax\".","category":"page"},{"location":"examples/#Extraction","page":"Examples","title":"Extraction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, say you need to create a climate scenario, using a given simulation, over a region defined by the following polygon.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"poly_reg = [[NaN -65 -80 -80 -65 -65];[NaN 42 42 52 52 42]]\n2×6 Array{Float64,2}:\n NaN  -65.0  -80.0  -80.0  -65.0  -65.0\n NaN   42.0   42.0   52.0   52.0   42.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The extraction of the desired variable can be done with the load function, by providing the polygon.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"gcmfiles =[\"tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc\",\n\"tasmax_day_MIROC5_historical_r1i1p1_19900101-19991231.nc\",\n\"tasmax_day_MIROC5_historical_r1i1p1_20000101-20091231.nc\"]\n\nmodel = load(gcm_files, \"tasmax\", poly=poly_reg)\nClimGrid struct with data:\n   3-dimensional AxisArray{Float32,3,...} with axes:    \n    :lon, [-78.75, -77.3438, -75.9375, -74.5313, -73.125, -71.7188, -70.3125, -68.9063, -67.5, -66.0938]\n    :lat, [42.7233, 44.1241, 45.5249, 46.9256, 48.3264, 49.7271, 51.1279]\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  …  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\nAnd data, a 10×7×10950 Array{Float32,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: day\nGlobal attributes: Dict{Any,Any} with 27 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"One possible verification of the extracted data is to map the time-mean data with the mapclimgrid function to see if there is something wrong.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mapclimgrid(model, region = \"Quebec\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Which should return the following map.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: MIROC5)","category":"page"},{"location":"examples/#Sidenote:-merging-files/data","page":"Examples","title":"Sidenote: merging files/data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Climate data files are usually on the order of multiple GBs and institution generally split a single simulation into multiple files. In order to calculate climatologies, it is thus essential to merge the data into a single structure. The function merge is provided to combine 2 ClimGrid.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"C = merge(C1, C2) # merge C1 with C2","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The merge function is useful when you have 2 or 3 files. However, a single simulation can sometimes be splitted into yearly files. Hence, extracting timeseries on climatological timescales can imply loading more than a hundred files just to get a complete timeserie for a given gridpoint. The function load has a method where the 1st positional argument is an Array of strings (as opposed to a single string).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"C = load(strarray::Array{String,1}, variable::String; poly, start_date::Tuple, end_date::Tuple, data_units::String))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is how the MIROC5 simulation has been loaded.","category":"page"},{"location":"examples/#Bias-correction","page":"Examples","title":"Bias correction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"An important step in climate scenarios design is to correct the statistical bias of the simulations compared against a chosen reference (more often than not, weather observations). A typical method is to do quantile-quantile mapping between the simulation timeseries and observed timeseries. The function qqmap does so. First step would be to interpolate the simulated field onto the reference grid. Here we use the dataset provided by the Canadian Forest Service (McKenney et al. 2011) for the interpolation step and the bias correction step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"McKenney, D. W., Hutchinson, M.F., Papadopol, P., Lawrence, K., Pedlar, J., Campbell, K., Milewska, E., Hopkinson, R., Price, D., Owen, T. (2011). \"Customized spatial climate models for North America.\" Bulletin of American Meteorological Society-BAMS December: 1612-1622.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"obsfiles = [\"nrcan_canada_daily_tasmax_1950.nc\",\n\"nrcan_canada_daily_tasmax_1951.nc\",\n\"nrcan_canada_daily_tasmax_1952.nc\",\n\"nrcan_canada_daily_tasmax_1953.nc\",\n\"nrcan_canada_daily_tasmax_1954.nc\",\n\"nrcan_canada_daily_tasmax_1955.nc\",\n\"nrcan_canada_daily_tasmax_1956.nc\",\n\"nrcan_canada_daily_tasmax_1957.nc\",\n\"nrcan_canada_daily_tasmax_1958.nc\",\n\"nrcan_canada_daily_tasmax_1959.nc\",\n\"nrcan_canada_daily_tasmax_1960.nc\",\n\"nrcan_canada_daily_tasmax_1961.nc\",\n\"nrcan_canada_daily_tasmax_1962.nc\",\n\"nrcan_canada_daily_tasmax_1963.nc\",\n\"nrcan_canada_daily_tasmax_1964.nc\",\n\"nrcan_canada_daily_tasmax_1965.nc\",\n\"nrcan_canada_daily_tasmax_1966.nc\",\n\"nrcan_canada_daily_tasmax_1967.nc\",\n\"nrcan_canada_daily_tasmax_1968.nc\",\n\"nrcan_canada_daily_tasmax_1969.nc\"]\n\nobs = load(obsfiles, \"tasmax\", poly=poly_reg)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mapclimgrid(obs, region = \"Quebec\", titlestr=\"Gridded Obs, 1980-2009\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: NRCAN)","category":"page"},{"location":"examples/#Interpolation-/-Regridding","page":"Examples","title":"Interpolation / Regridding","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The interpolation is done with the regrid function. The following command interpolate the values of ClimGrid model onto the grid of ClimGrid obs.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"modelinterp = regrid(model, obs)\nProgress: 100%|█████████████████████████████████████████| Time: 0:00:38\nClimGrid struct with data:\n   3-dimensional AxisArray{Float64,3,...} with axes:    \n    :lon, Float32[-79.9583, -79.875, -79.7917, -79.7083, -79.625, -79.5417, -79.4583, -79.375, -79.2917, -79.2083  …  -65.7917, -65.7083, -65.625, -65.5417, -65.4583, -65.375, -65.2917, -65.2083, -65.125, -65.0417]\n    :lat, Float32[51.9583, 51.875, 51.7917, 51.7083, 51.625, 51.5417, 51.4583, 51.375, 51.2917, 51.2083  …  42.7917, 42.7083, 42.625, 42.5417, 42.4583, 42.375, 42.2917, 42.2083, 42.125, 42.0417]\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  …  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\nAnd data, a 180×120×10950 Array{Float64,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: day\nGlobal attributes: Dict{Any,Any} with 27 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> mapclimgrid(modelinterp, region = \"Quebec\", titlestr=\"MIROC5 - Interpolated - 1980-2009\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: MIROC5_INTERP)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Notice that there is no new information created here. The interpolation is using Scipy's griddata under the hood and is simply a linear interpolation onto the obs grid.","category":"page"},{"location":"examples/#Quantile-quantile-mapping","page":"Examples","title":"Quantile-quantile mapping","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The high-resolution local information is integrated into ClimGrid modelinterp at the bias correction step. There is a daily transfer function applied on a quantile basis.The call signature is qqmap(obs, ref, fut) where the transfer function is estimated between obs and ref and applied on fut. Note that ref and fut can be the same, as in this example. A typical use-case would be obs and ref covering the same (historical, e.g. 1961-2010) temporal window and fut being a simulation covering a future climatological period (which could be a mix of historic and future, such as 1961-2090). This step is computationally intensive (uses of multiple threads can help here if set by the user).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"model_qqmap = qqmap(obs, modelinterp, modelinterp)\nProgress: 100%|█████████████████████████████████████████| Time: 0:11:20\nClimGrid struct with data:\n   3-dimensional AxisArray{Float64,3,...} with axes:    \n    :lon, Float32[-79.9583, -79.875, -79.7917, -79.7083, -79.625, -79.5417, -79.4583, -79.375, -79.2917, -79.2083  …  -65.7917, -65.7083, -65.625, -65.5417, -65.4583, -65.375, -65.2917, -65.2083, -65.125, -65.0417]\n    :lat, Float32[51.9583, 51.875, 51.7917, 51.7083, 51.625, 51.5417, 51.4583, 51.375, 51.2917, 51.2083  …  42.7917, 42.7083, 42.625, 42.5417, 42.4583, 42.375, 42.2917, 42.2083, 42.125, 42.0417]\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  …  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\nAnd data, a 180×120×10950 Array{Float64,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: NA\nGlobal attributes: Dict{Any,Any} with 0 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Mapping the results show that the local information is integrated into the model, and that the natural \"mask\" of the observation grid is applied naturally.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mapclimgrid(model_qqmap, region = \"Quebec\", titlestr=\"MIROC5 - Interpolated and Quantile-Quantile corrected - 1980-2009\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: MIROC5_QQMAP)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Proper assessment of future climate conditions over the specified region would involve replicating these steps for minimally a dozen simulations from multiple models and different emission scenarios (e.g. RCP4.5, RCP8.5, etc.).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can show the effect of bias correction by simply subtracting model_qqmap from modelinterp.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mapclimgrid(modelinterp-model_qqmap, region = \"qc\", titlestr=\"MIROC5 - bias correction effect - 1980-2009\", center_cs=true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: MIROC5_effect)","category":"page"},{"location":"examples/#Climate-indices","page":"Examples","title":"Climate indices","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once the climate data is downscaled (interpolation and bias correction) to the proper scale, the user can compute climate indices. For example, annual maximum values of daily maximum temperature could be desired (annualmax).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"annmax = annualmax(model_qqmap)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The return value of climate indices functions are another ClimGrid, but at the yearly scale in the case of annual maximum. Maps and timeseries can be plotted with mapclimgrid and plot respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here's the effect of bias correcting on annual maximum values.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"max_obs = annualmax(obs)\nmax_modelinterp = annualmax(modelinterp)\nmax_modelqqmap = annualmax(model_qqmap)\n\n# Plots\nplot(max_obs, label=\"OBS\")\nplot(max_modelinterp, label=\"MIROC5 - interpolated\")\nplot(max_modelqqmap, label=\"MIROC5 - bias corrected\", titlefig = \"Effect of bias correction on annual maximum values\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: timeseries)","category":"page"},{"location":"examples/#Exporting","page":"Examples","title":"Exporting","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once calculations are done, results can be written to disk to a netCDF file with the write command. Here, we export the annual maximum values of the bias corrected model to the current folder.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write(max_modelqqmap, \"annualmax_model_qqmap.nc\")","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Installing-ClimateTools.jl","page":"Installation","title":"Installing ClimateTools.jl","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Once the Python dependencies are properly installed you can then install ClimateTools in Julia.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add ClimateTools # Tagged release","category":"page"},{"location":"installation/#Installing-ClimatePlots.jl","page":"Installation","title":"Installing ClimatePlots.jl","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Plotting data and results is done through the ClimatePlots.jl package.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Under the hood, ClimatePlots.jl requires some Python packages for mapping purpose and is currently using Cartopy. To ensure that ClimatePlots works properly, it is recommended to use Julia's built-in Python distribution which can properly load the required Python packages.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Hence, the best approach is to simply configure PyCall as follows:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg; Pkg.add(\"PyCall\")\njulia> ENV[\"PYTHON\"]=\"\"\njulia> Pkg.build(\"PyCall\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Then, once PyCall configured, installation is the standard command.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add ClimatePlots # Tagged release","category":"page"},{"location":"installation/#Alternatives-Python-distribution","page":"Installation","title":"Alternatives Python distribution","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"It is also possible to use your own Python distribution instead of Julia's Python.","category":"page"},{"location":"installation/#Approach-no.-1-Use-Anaconda-or-main-system-Python-distribution","page":"Installation","title":"Approach no. 1 Use Anaconda or main system Python distribution","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The first approach is to use Anaconda or the system Python distribution and ensure that you can import the following packages. By far, the easiest solution is to use Anaconda, which can easily install the Basemap dependency.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"1.1 Python dependencies","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"matplotlib\ncartopy\ncmocean","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"1.2 Testing Python installation","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"No matter the approach used, it is recommended to test the Python environment and see if you can import the required Python packages.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"#python\n>>> import cartopy\n>>> import matplotlib.pyplot as plt\n>>> import cmocean as cm","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"1.2 Building PyCall After the confirmation that the Python dependencies can be loaded in Python, the user needs to build PyCall with the same Python version. Alternatively, if PyCall is already built, it may be only a matter of installing the Python dependencies with the PyCall's Python version by using pip.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ENV[\"PYTHON\"]=\"path_to_python_distribution\"\npkg> build PyCall","category":"page"},{"location":"installation/#Approach-no.-2.-Use-a-Conda-virtual-environment-and-link-PyCall.jl-to-it","page":"Installation","title":"Approach no. 2. Use a Conda virtual environment and link PyCall.jl to it","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If the main system Python distribution is not set-up properly, the recommended approach is to use a Conda environment. Cartopy is much easier to install through this approach. It is simply a matter of creating a virtual Python environment with Conda and installing the required packages and then linking Julia's PyCall.jl package to this virtual Conda environment. More information can be found in PyCall documentation for custom Conda environment.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Create a virtual environment with Conda","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"$ conda create -name ClimateTools python=3.6\n$ conda activate ClimateTools\n$ conda install -c conda-forge matplotlib --strict-channel-priority\n$ conda install -c conda-forge cartopy --strict-channel-priority\n$ conda install -c conda-forge cmocean --strict-channel-priority\n$ which python # gives you the path of Conda virtual environment to use in the next steps.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Once those packages are installed, you need to tell PyCall.jl (in Julia) to use this Conda environment in Julia.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using PyCall\njulia> ENV[\"PYTHON\"]=\"...PATH TO CONDA PYTHON...\" # find the path with \"which python\" at previous step\njulia> using Pkg; Pkg.build(\"PyCall\")","category":"page"},{"location":"biascorrection/#Bias-correction","page":"Bias correction","title":"Bias correction","text":"","category":"section"},{"location":"biascorrection/","page":"Bias correction","title":"Bias correction","text":"Quantile-quantile mapping (Themeßl et al. 2012, Grenier et al. 2015) is provided with ClimateTools.jl through the function qqmap.","category":"page"},{"location":"biascorrection/","page":"Bias correction","title":"Bias correction","text":"qqmap(obs::ClimGrid, ref::ClimGrid, fut::ClimGrid; method::String=\"Additive\", detrend::Bool=true, window::Int=15, rankn::Int=50, thresnan::Float64=0.1, keep_original::Bool=false, interp = Linear(), extrap = Flat())","category":"page"},{"location":"biascorrection/","page":"Bias correction","title":"Bias correction","text":"More information can be found in these references.","category":"page"},{"location":"biascorrection/","page":"Bias correction","title":"Bias correction","text":"Themeßl, Matthias Jakob, Andreas Gobiet, and Georg Heinrich. 2012. “Empirical-Statistical Downscaling and Error Correction of Regional Climate Models and Its Impact on the Climate Change Signal.” Climatic Change 112 (2). Springer: 449–68.","category":"page"},{"location":"biascorrection/","page":"Bias correction","title":"Bias correction","text":"Grenier, Patrick, Ramón de Elía, and Diane Chaumont. 2015. “Chances of Short-Term Cooling Estimated from a Selection of CMIP5-Based Climate Scenarios during 2006-2035 over Canada.” Journal of Climate, January 2015. American Meteorological Society. doi:10.1175/JCLI-D-14-00224.1.","category":"page"},{"location":"interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"A typical step in climate analysis is to interpolate a given grid onto another grid. ClimateTools provides such a tool by wrapping Scipy griddata function. It is intended for visualization or as a 1st step before bias-correcting the ClimGrid dataset.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"griddata function will interpolate the data contained in ClimGrid A into the coordinates of ClimGrid B and returns a new ClimGrid C which contains the interpolated data of A into the grid of B.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"C = griddata(A::ClimGrid, B::ClimGrid)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"It is also possible to interpolate a ClimGrid onto specified longitude and latitude vectors and arrays.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"C = griddata(A::ClimGrid, lon::AbstractArray{N, T} where N where T, lat::AbstractArray{N, T} where N where T; dimx=[], dimy=[], method::String=\"linear\", min=[], max=[])","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"In the case a longitude and latitude 2D array is provided, the user needs to provide the dimension vectors for x and y.","category":"page"},{"location":"interpolation/#Experimental","page":"Interpolation","title":"Experimental","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"DEPRECATED. Users will have to define their own regridding functions using GeoStats.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"ClimateTools also provide a way to uses GeoStats geostatistics methods. See function regrid for some details.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"using GeoStats\nusing ClimateTools\n\ntarget = :pr # e.g. precipitation\nn = 30 # max number of neighboring points\nsolver = Kriging(target => (maxneighbors=n,))\n\nC = regrid(A::ClimGrid, B::ClimGrid, solver=solver)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimateTools.jl is a collection of commonly-used tools in Climate science. Basics of climate field analysis will be covered, with some forays into exploratory techniques. The package is aimed to ease the typical steps of analysis climate models outputs from netCDF files that follows Climate Forecast conventions and the creation of climate scenarios.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The idea behind ClimateTools is that most, if not all, climate fields can be represented by a 2D (e.g. topography), 3D (e.g. air temperature) or 4D (e.g. winds at multiple levels) grids that are georeferenced. Those grids are named ClimGrid in ClimateTools. Every functions acts on such structure and returns a similar structure. The ClimGrid structure contains all elements needed to be manipulated: latitude, longitude, calendars, variable attributes, etc. that was either available in the original netCDF file or that was inferred by the metadata. Note that a ClimGrid is defined for a single variable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The metadata follows the various transformations and is modified when necessary. For example, calculating the annual number of days with precipitation higher than 1mm will modify the variable name from pr (for precipitation) to prcp1, the name of the indicator. It will not, however, modify the base variable type (it will remain pr).","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The climate indices and bias correction functions are coded to leverage multiple threads. To gain maximum performance, use (bash shell Linux/MacOSX) export JULIA_NUM_THREADS=n, where n is the number of threads. To get an idea of the number of threads you can use type (in Julia) Sys.THREADS. This is especially useful for bias correction.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Climate scenarios creation\nExtraction and visualization of CF-compliant netCDF datasets\nCustom user-provided polygons and start and end date for localized studies\nClimate indices from The joint CCl/CLIVAR/JCOMM Expert Team (ET) on Climate Change Detection and Indices (ETCCDI) as well as custom climate indices\nRegridding of a datasets onto another grid\nPost-processing of climate timeseries using Quantile-Quantile mapping method (cf. Themeßl et al. 2012, Piani et al. 2010)\nExportation of results to a CF-compliant netCDF file\nSupport for typical climate models calendars: 360day, 365day, Standard, Prolectip Gregorian through NCDatasets.jl.\nSupport for physical units through the Unitful.jl package.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you'd like to have other climate indices coded, please, submit them through a Pull Request! I'd be more than happy to include them. Alternatively, provide the equation in Issues.","category":"page"},{"location":"#TO-DO","page":"Home","title":"TO-DO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dashboard tool. This will return the main characteristics of a ClimGrid: maps of minimum, maximum and mean climatological values, seasonal cycle, timeseries of annual maximum, minimum and mean values, etc...\nExtreme value theory analysis","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION)\") # hide","category":"page"},{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"datasets/#Importing-a-NetCDF-dataset","page":"Datasets","title":"Importing a NetCDF dataset","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"The entry point of ClimateTools is to load data with the load function. The return structure of the load function is a in-memory representation of the variable contained in the netCDF file.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"For a single-file dataset.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"C = load(filename::String, vari::String; poly::Array, data_units::String, start_date::Tuple, end_date::Tuple, dimension::Bool=true)","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"or, for a multi-file datasets.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"C = load(filename::Array{String}, vari::String; poly::Array, data_units::String, start_date::Tuple, end_date::Tuple, dimension::Bool=true)","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"load return a ClimGrid type. The ClimGrid represent a single variable. By default, the function tries to attach physical units to the data array by using the Unitful.jl package. The advantage behind physical units is that one can subtract a ClimGrid with Kelvin unit with a ClimGrid with Celsius unit and get coherent results. Be warned that some operations on some units are not allowed (you cannot \"add\" Celsius for instance). In the event that a user wants to do some calculations without physical logic, it is possible to load the dataset without the units by specifying dimension=false argument.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Using the optional poly argument, the user can provide a polygon and the returned ClimGrid will only contains the grid points inside the provided polygon. The polygon provided should be in the -180, +180 longitude format. If the polygon crosses the International Date Line, the polygon should be splitted in multiple parts (i.e. multi-polygons).","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"start_date and end_date can also be provided. It is useful when climate simulations file spans multiple decades/centuries and only a temporal subset is needed. Dates should be provided as a Tuple of the form (year, month, day, hour, minute, seconds), where only year is mandatory (e.g. (2000,) can be provided and will defaults to (2000, 01, 01)).","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"For some variable, the optional keyword argument data_units can be provided. For example, precipitation in climate models are usually provided as kg/m^2/s. By specifying data_units = mm, the load function returns accumulation at the data time resolution. Similarly, the user can provide Celsius as data_units and load will return Celsius instead of Kelvin.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"struct ClimGrid\n  data::AxisArray # Data\n  longrid::AbstractArray{N,2} where N # the longitude grid\n  latgrid::AbstractArray{N,2} where N # the latitude grid\n  msk::Array{N, 2} where N # Data mask (NaNs and 1.0)\n  grid_mapping::Dict#{String, Any} # bindings for native grid\n  dimension_dict::Dict\n  model::String\n  frequency::String # Day, month, years\n  experiment::String # Historical, RCP4.5, RCP8.5, etc.\n  run::String\n  project::String # CORDEX, CMIP5, etc.\n  institute::String # UQAM, DMI, etc.\n  filename::String # Path of the original file\n  dataunits::String # Celsius, kelvin, etc.\n  latunits::String # latitude coordinate unit\n  lonunits::String # longitude coordinate unit\n  variable::String # Type of variable (i.e. can be the same as \"typeofvar\", but it is changed when calculating indices)\n  typeofvar::String # Variable type (e.g. tasmax, tasmin, pr)\n  typeofcal::String # Calendar type\n  timeattrib::Dict # Time attributes (e.g. days since ... )\n  varattribs::Dict # Variable attributes dictionary\n  globalattribs::Dict # Global attributes dictionary\nend","category":"page"},{"location":"datasets/#Manipulations","page":"Datasets","title":"Manipulations","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Once the data is loaded in a ClimGrid struct, options to further subset the data are available.","category":"page"},{"location":"datasets/#Spatial","page":"Datasets","title":"Spatial","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"spatialsubset function acts on ClimGrid type and subset the data through a spatial subset using a provided polygon. The function returns a ClimGrid. Polygons needs to be on a -180, +180 longitude coordinates, as data coordinates defaults to such grid. For instance, global models are often on a 0-360 degrees grid but the load function shift the data onto a -180,+180 coordinates.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"C = spatialsubset(C::ClimGrid, poly:Array{N, 2} where N)","category":"page"},{"location":"datasets/#Temporal","page":"Datasets","title":"Temporal","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Temporal subset of the data is also possible with the temporalsubset function:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"C = temporalsubset(C::ClimGrid, startdate::Tuple, enddate::Tuple)","category":"page"},{"location":"datasets/#Discontinuous-temporal-(e.g.-resampling)","page":"Datasets","title":"Discontinuous temporal (e.g. resampling)","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"It is also possible to only keep a given non-continuous period for a given timeframe. For example, we might be interested in keeping only northern summer months (June-July-August) from a continuous ClimGrid covering 1961-2100. resample returns such a subsetted ClimGrid.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Csub = resample(C, \"JJA\") # hardcoded ClimateTools's season\nCsub = resample(C, 6, 8) # custom subset example for June-July-August\nCsub = resample(C, 1, 2) # custom subset example for January-February","category":"page"}]
}
